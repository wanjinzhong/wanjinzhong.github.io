(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{541:function(v,_,t){"use strict";t.r(_);var l=t(4),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"一、小镇的新餐厅"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、小镇的新餐厅"}},[v._v("#")]),v._v(" 一、小镇的新餐厅")]),v._v(" "),t("p",[v._v("  从前，有一个原始的小镇，镇上的人们都爱去餐厅吃饭。当然了，与其他小镇不同的是，这个小镇的餐厅老板才是上帝，他怎么安排，顾客就要乖乖地听。")]),v._v(" "),t("p",[v._v("  餐厅刚刚开业的时候，老板没有一丁点经验，直接让顾客端着吃。每次来一个顾客点了一碗炒饭，后厨就做好这份炒饭，然后让服务员把炒饭端给顾客。等顾客吃完炒饭，叫一声：“服务员，我吃完了过来收盘子~”。服务员又赶紧跑过去把盘子收回来。")]),v._v(" "),t("p",[v._v("  先开始大家都还忙的过来，因为一开始顾客并不多。可是随着生意越来越好，来来往往的顾客越来越多。服务员开始向老板抱怨，说特别累，每次来一个顾客我要给他端饭过去，等他吃完了，我还要跑过去把盘子收回来；而且这样会让餐厅特别没有条理。体恤员工的老板其实看在眼里，也慢慢陷入了沉思。")]),v._v(" "),t("h3",{attrs:{id:"二、改革-餐厅重新设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、改革-餐厅重新设计"}},[v._v("#")]),v._v(" 二、改革-餐厅重新设计")]),v._v(" "),t("p",[v._v("  面对越来越多的顾客，和越来越劳累的员工。终于有一天，老板想：既然以前员工服务一个顾客需要跑两趟，那现在我让他们每次只跑一趟不就好了吗。于是老板终于想出了解决办法，并开始按照新办法来执行。于是，餐厅进行了改革。")]),v._v(" "),t("p",[v._v("  当然，第一件事就是要重新装修一下餐厅，毕竟让顾客每次端着吃也不好。老板画出了他理想中的装修图：")]),v._v(" "),t("p",[v._v("其中：")]),v._v(" "),t("ul",[t("li",[v._v("大圆桌可以容纳8人同时就餐")]),v._v(" "),t("li",[v._v("服务员排队通道：顾名思义，是给服务员排队给客人上菜用的，老板设计的这个通道长度可以容纳10个服务员排队")]),v._v(" "),t("li",[v._v("杂物间：这个地方本身是用于其他地方的，但是在特殊情况下可以收拾出来临时给客人就餐")])]),v._v(" "),t("h3",{attrs:{id:"三、重新开业"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、重新开业"}},[v._v("#")]),v._v(" 三、重新开业")]),v._v(" "),t("p",[v._v("  按照老板的设计，今天重新开业了。老板让服务员首先在桌子上准备好8个盘子，这样客人一来，后厨把菜做好就可以直接放在盘子里面了。（当然，根据老板的心情也可以等客人来了再一个一个准备盘子）")]),v._v(" "),t("p",[v._v("  一会儿，来了8个客人，餐厅桌子刚好坐满。现在是餐厅运营最合理的时候了。可是一会儿又来了几个客人，然而前面那8个客人还没有吃完。此时，只能让后来的客人先等着，服务员准备好他们的菜之后按照顺序在服务员排队通道排队。当前面的客人在桌子上就餐完毕之后，再让排队通道的服务员依次把菜放到桌子上的盘子里，对应的客人就可以来就餐了。这样，每次服务员服务一名客人的时候，只需要把菜拿去放在盘子里就行了，不需要收盘子。服务员只需要跑一趟，大大减少了服务员的工作量。")]),v._v(" "),t("p",[v._v("  快到中午了，吃饭的客人越来越多。餐桌坐满了8人，还有10个服务员正在排队。饭桌和排队通道已经容纳不下再多的客人了。此时，杂物间排上用场。老板把在杂物间收拾出来，摆了一张餐桌，这张餐桌只能容纳5个人。当主餐桌的位置不够，而排队通道也客满的话，就安排客人去杂物间直接就餐。一切都井井有条地进行着。")]),v._v(" "),t("p",[v._v("  有一天，厨师问了老板一个棘手的问题：如果主餐桌、排队通道、杂物间都客满了怎么办。老板思考了一下，说：我想到了四种解决方案，我每天早上开门的时候会告诉你使用其中一种方案，这四种方案分别是：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("ol",[t("li",[v._v("全满了那就直接赶走新来的客人，并且告诉我赶走了客人")]),v._v(" "),t("li",[v._v("和第一点一样，全满了就赶走新来的客人，但是不必再告诉我了")]),v._v(" "),t("li",[v._v("让排在排队通道的第一个服务员不再服务他将要服务的那个客人，回厨房重新拿一盘新客人的菜，重新排在通道的最后，为新来的客人服务")]),v._v(" "),t("li",[v._v("让新客人自己拿着菜去旁边蹲着吃")])])]),t("p",[v._v("  厨师按照老板的要求，一直稳定地运营着。可是细心的服务员发现，有的客人吃完饭了就坐在那儿看报休息，完全不顾还有客人等着吃饭，或者有些客人被挤到了杂物间吃饭，甚至是被餐厅拒绝服务。这样总归是不好的。请示了老板之后，老板又给出了几种解决方案，也是每天开门的时候，老板告诉服务员使用哪一种方案。这几种方案分别是：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("ol",[t("li",[v._v("顾客是上帝，就算他们在看报休息，也不要管他们")]),v._v(" "),t("li",[v._v("无论客人多不多，只要看见客人吃了饭看报休息到了一定时间，就赶他走，并且收掉他们的盘子，好让排队的客人早点就餐（当然，至于是休息多长时间才赶走，需要老板来指定）")]),v._v(" "),t("li",[v._v("当主餐桌坐满了客人，杂物间也坐的有客人的时候，如果客人吃了饭看报休息到了一定时间，就赶走他，收掉盘子，直到不超过8个人就餐（也就是主餐桌的人数）")])])]),t("p",[v._v("  这样一来，餐厅运营有条不紊。每天，餐厅都等到最后一位客人就完餐，就收工关门。保证每一位客人都能吃完饭。可是突然有一天，老板接到电话，说他老婆感冒了，要老板回去照顾她。但是这不是紧急的事情，老板就告诉厨师，不再接收新的客人，但是不能打扰正在吃饭的客人，让他们吃完，等所有的客人都吃完了，再关门回家。")]),v._v(" "),t("p",[v._v("  几天之后，老板又接到一个电话，说他老婆生了。这么重要的事情，肯定要第一时间赶回去。于是老板命令厨师不再接收新客人，然后让服务员收走所有人的盘子，把他们赶走，马上关门回家。")]),v._v(" "),t("h3",{attrs:{id:"四、回归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、回归"}},[v._v("#")]),v._v(" 四、回归")]),v._v(" "),t("p",[v._v("  好了，故事讲完了，现在我们回归到java的线程池中。")]),v._v(" "),t("p",[v._v("  首先，我们试着把线程池的概念映射到这个餐厅中，看看线程池的每个元素在餐厅中都扮演什么角色吧。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("ol",[t("li",[v._v("餐厅：我们的计算机硬件。因为硬件有限，导致我们同时运行巨大数量线程的时候，可能会导致计算机CPU负载过高或者内存溢出")]),v._v(" "),t("li",[v._v("主餐桌：对应核心线程数（corePoolSize），核心线程池的大小可以指定")]),v._v(" "),t("li",[v._v("杂物间餐桌：杂物间餐桌+主餐桌大小就是线程池最大的线程数（\nmaximumPoolSize）")]),v._v(" "),t("li",[v._v("排队通道：对应工作队列（workQueue）。这个工作队列存放了待执行的任务。")]),v._v(" "),t("li",[v._v("盘子：一个盘子对应一个线程")]),v._v(" "),t("li",[v._v("饭菜：对应任务。任务要放在线程中运行，就像饭菜要放在盘子里吃一样。")])])]),t("p",[v._v("当创建线程池的时候，需要指定一下几个参数：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("ul",[t("li",[v._v("corePoolSize（int）：核心线程数。线程池创建的时候默认不初始化线程，等有任务来的时候才会创建线程。除非调用了prestartAllCoreThreads()来创建所有空线程，或者prestartCoreThread() 来创建一个空线程。就像每天早上老板决定是该提前把盘子都准备好，还是等客人来了再按需准备一样。")]),v._v(" "),t("li",[v._v("maximumPoolSize（int）：最大线程数")]),v._v(" "),t("li",[v._v("keepAliveTime（long）：最大的休息时间。表示线程没有任务执行时，超过多长时间终止这个线程（和下面的时间单位参数一起使用 ）。一般地，当线程池的线程数超过corePoolSize时，开始按照这个时间来终止线程。但是，如果调用了allowCoreThreadTimeOut(boolean)方法，那么不管有没有超过核心线程池大小，也会直接终止那些超过最大空闲时间的线程。就像老板决定如果客人太多，需不需要将那些吃了饭看报休息的客人的盘子收走一样。")]),v._v(" "),t("li",[v._v("unit（TimeUnit）：时间单位")]),v._v(" "),t("li",[v._v("workQueue （BlockingQueue<Runnable>）：阻塞队列，当这个队列不指定大小时是个无界队列。，可选：\n"),t("ul",[t("li",[v._v("ArrayBlockingQueue")]),v._v(" "),t("li",[v._v("LinkedBlockingQueue（用得最多）")]),v._v(" "),t("li",[v._v("SynchronousQueue（一次只能一个任务执行，和单线程差不多）")])])]),v._v(" "),t("li",[v._v("threadFactory：可选。线程工厂，主要用来创建线程")]),v._v(" "),t("li",[v._v("handler：表示当拒绝处理任务时的策略，可选如下：\n"),t("ul",[t("li",[v._v("ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。直接赶走新来客人并且报告老板")]),v._v(" "),t("li",[v._v("ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。直接赶走新来的客人但是不报告老板")]),v._v(" "),t("li",[v._v("ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。将排在排队通道最前面的那个服务员移除出去")]),v._v(" "),t("li",[v._v("ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 。让客人自己端着盘子去旁边蹲着吃")])])])])]),t("p",[v._v("  当任务来了，流程是这样的：")]),v._v(" "),t("p",[v._v("  首先看看当前线程池的线程数有没有达到核心线程数，如果没有达到，就直接创建线程来运行任务；如果达到了核心线程数，就尝试放入工作队列，等待执行；如果工作队列也满了，就看看当前线程池的线程数有没有达到最大线程数，如果没有达到最大线程数，就创建线程来运行；如果达到最大线程数了，就按照指定的拒绝策略来处理。")]),v._v(" "),t("br"),v._v(" "),t("hr"),v._v(" "),t("br"),v._v(" "),t("Vssue",{attrs:{title:v.$title}})],1)}),[],!1,null,null,null);_.default=i.exports}}]);